#include "stdafx.h"
#include "MemoryLocation.h"

#define DISTANCE_Z	300.0
#define FLYSTATUS	4278190208

/*These are the offsets for the World of Warcraft client in version
*3.3.5, build 12340
*These offsets are always the same when the program launch.
*/
enum ObjectOffsets : DWORD
{
	Type = 0x14,
	Pos_X = 0x79C,
	Pos_Y = 0x798,
	Pos_Z = 0x7A0,
	Rot = 0x7A8,
	Guid = 0x30,
	UnitFields = 0x8,
	Swimming = 0x75E439,
	Flying = 0x7CF,
	Corpse_Pos_X = 0xBD0A5C,
	Corpse_Pos_Y = 0xBD0A58,
	Corpse_Pos_Z = 0xBD0A60,
	Movement = 0x81C,
	Water_walk = 0x75E439
};

enum UnitOffsets : DWORD
{
	Level = 0x36 * 4,
	Health = 0x18 * 4,
	Energy = 0x19 * 4,
	MaxHealth = 0x20 * 4,
	SummonedBy = 0xE * 4,
	MaxEnergy = 0x21 * 4
};

enum ClientOffsets : DWORD
{
	StaticClientConnection = 0x00C79CE0,
	ObjectManagerOffset = 0x2ED0,
	FirstObjectOffset = 0xAC,
	LocalGuidOffset = 0xC0,
	NextObjectOffset = 0x3C,
	LocalPlayerGUID = 0xBD07A8,
	LocalTargetGUID = 0x00BD07B0,
	MapId = 0x0BD080C,
	ZoneId = 0x00D38AC4,
	IsFlying = 0x44
};

enum NameOffsets : DWORDLONG
{
	nameStore = 0x00C5D938 + 0x8,
	nameMask = 0x24,
	nameBase = 0x1C,
	nameString = 0x20
};

FLOAT MemoryLocation::ReadCorpsePos(DWORD offset)
{
	LoadFromMemory();

	FLOAT pos = mem.ReadFloat((LPVOID)(offset));
	return pos;
}

void MemoryLocation::WriteCorpsePos(DWORD offset, FLOAT pos)
{
	LoadFromMemory();

	if (pos != NULL) {
		mem.WriteFloat((LPVOID)(offset), pos);
	}
}

void MemoryLocation::MoveToCorpse() {
	
	FLOAT x = ReadCorpsePos(ObjectOffsets::Corpse_Pos_X);
	FLOAT y = ReadCorpsePos(ObjectOffsets::Corpse_Pos_Y);
	FLOAT z = ReadCorpsePos(ObjectOffsets::Corpse_Pos_Z);

	WritePos(x, y, z);
}

void MemoryLocation::MoveCorpseToPlayer() {
	FLOAT x = ReadPosX();
	FLOAT y = ReadPosY();
	FLOAT z = ReadPosZ();

	WriteCorpsePos(ObjectOffsets::Corpse_Pos_X, x);
	WriteCorpsePos(ObjectOffsets::Corpse_Pos_Y, y);
	WriteCorpsePos(ObjectOffsets::Corpse_Pos_Z, z);
}

void MemoryLocation::WriteSpeed(FLOAT speed) 
{
	LoadFromMemory();

	mem.WriteFloat((LPVOID)(playerBase + ObjectOffsets::Movement), speed);
}

FLOAT MemoryLocation::ReadSpeed() 
{
	LoadFromMemory();

	FLOAT speed = mem.ReadFloat((LPVOID)(playerBase + ObjectOffsets::Movement));

	return speed;
}

DWORD MemoryLocation::GetObjectBaseByGuid(DWORD firstObject, DWORDLONG guid) 
{

	DWORD baseTmp = firstObject;
	DWORDLONG tmpGuid;

	while (baseTmp != 0)
	{
		tmpGuid = mem.ReadUInt64((LPVOID)(baseTmp + ObjectOffsets::Guid));

		if (tmpGuid == guid) {
			return baseTmp;
		}

		baseTmp = mem.ReadUInt32((LPVOID)(baseTmp + ClientOffsets::NextObjectOffset));
	}

	return 0;
}

void MemoryLocation::LoadFromMemory() 
{

	clientConnection = mem.ReadUInt32((LPVOID)ClientOffsets::StaticClientConnection);
	objectManager = mem.ReadUInt32((LPVOID)(clientConnection + ClientOffsets::ObjectManagerOffset));
	firstObject = mem.ReadUInt32((LPVOID)(objectManager + ClientOffsets::FirstObjectOffset));
	targetGuid = mem.ReadUInt64((LPVOID)(ClientOffsets::LocalTargetGUID));
	playerGuid = mem.ReadUInt64((LPVOID)(objectManager + ClientOffsets::LocalGuidOffset));

	playerBase = GetObjectBaseByGuid(firstObject, playerGuid);
}

INT MemoryLocation::ReadMapId() 
{
	LoadFromMemory();

	INT mapId = mem.ReadInt((LPVOID)ClientOffsets::MapId);
	return mapId;
}

INT MemoryLocation::ReadZoneId() 
{

	LoadFromMemory();

	INT zoneId = mem.ReadInt((LPVOID)(playerBase + ClientOffsets::ZoneId));
	return zoneId;
}

void MemoryLocation::WritePos(FLOAT x, FLOAT y, FLOAT z) 
{

	LoadFromMemory();

	if (x != NULL) {
		mem.WriteFloat((LPVOID)(playerBase + ObjectOffsets::Pos_X), x);
	}

	if (y != NULL) {
		mem.WriteFloat((LPVOID)(playerBase + ObjectOffsets::Pos_Y), y);
	}

	if (z != NULL) {
		mem.WriteFloat((LPVOID)(playerBase + ObjectOffsets::Pos_Z), z);
	}
}

FLOAT MemoryLocation::ReadPosX() 
{
	LoadFromMemory();

	FLOAT x = mem.ReadFloat((LPVOID)(playerBase + ObjectOffsets::Pos_X));
	return x;
}

FLOAT MemoryLocation::ReadPosY() 
{
	LoadFromMemory();

	FLOAT y = mem.ReadFloat((LPVOID)(playerBase + ObjectOffsets::Pos_Y));

	return y;
}

FLOAT MemoryLocation::ReadPosZ() 
{

	LoadFromMemory();

	FLOAT z = mem.ReadFloat((LPVOID)(playerBase + ObjectOffsets::Pos_Z));

	return z;
}

void MemoryLocation::WritePosX(FLOAT x) 
{

	LoadFromMemory();

	if (x != NULL) {
		mem.WriteFloat((LPVOID)(playerBase + ObjectOffsets::Pos_X), x);
	}
}

void MemoryLocation::WritePosY(FLOAT y) 
{

	LoadFromMemory();

	if (y != NULL) {
		mem.WriteFloat((LPVOID)(playerBase + ObjectOffsets::Pos_Y), y);
	}
}

void MemoryLocation::WritePosZ(FLOAT z) 
{

	LoadFromMemory();

	if (z != NULL) {
		mem.WriteFloat((LPVOID)(playerBase + ObjectOffsets::Pos_Z), z);
	}
}

DWORD MemoryLocation::ReadHp() 
{

	LoadFromMemory();

	DWORD unitFieldsAddress = mem.ReadUInt32((LPVOID)(playerBase + ObjectOffsets::UnitFields));
	DWORD hp = mem.ReadUInt32((LPVOID)(unitFieldsAddress + UnitOffsets::Health));

	return hp;
}

void MemoryLocation::WriteHp(DWORD hp) 
{

	LoadFromMemory();

	DWORD unitFieldsAddress = mem.ReadUInt32((LPVOID)(playerBase + ObjectOffsets::UnitFields));
	mem.WriteUInt32((LPVOID)(unitFieldsAddress + UnitOffsets::Health), hp);
}

void MemoryLocation::WriteZoneId(INT id) 
{

	LoadFromMemory();

	mem.WriteInt((LPVOID)(ClientOffsets::ZoneId), id);
}

void MemoryLocation::LiftPosZ() 
{

	LoadFromMemory();

	FLOAT z = ReadPosZ() + DISTANCE_Z;

	WritePosZ(z);
}

void MemoryLocation::LandPosZ() 
{

	LoadFromMemory();

	FLOAT z = ReadPosZ() - DISTANCE_Z;

	WritePosZ(z);
}

void MemoryLocation::WriteFly(DWORD flying) 
{

	LoadFromMemory();

	DWORD current = ReadFly();

	if (current > FLYSTATUS) {
		//	flying = -flying;
	}

	DWORD fly = ReadFly() + flying;

	mem.WriteInt((LPVOID)(playerBase + ObjectOffsets::Flying), fly);
}

DWORD MemoryLocation::ReadFly() 
{

	LoadFromMemory();

	DWORD flying = mem.ReadInt((LPVOID)(playerBase + ObjectOffsets::Flying));

	return flying;
}

FLOAT MemoryLocation::ReadSwimming() 
{

	LoadFromMemory();

	DWORD unitFieldsAddress = mem.ReadUInt32((LPVOID)(playerBase + ObjectOffsets::UnitFields));
	FLOAT swimming = mem.ReadFloat((LPVOID)(ObjectOffsets::Swimming));

	return swimming;
}