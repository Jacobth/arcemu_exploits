#include "stdafx.h"
#include "mem_location.h"
#include<iostream>
#include<Windows.h>

#define DISTANCE_Z	300.0
#define FLYSTATUS	4278190208

using namespace std;


mem_location::mem_location()
{

}

/*These are the offsets for the World of Warcraft client in version
*3.3.5, build 12340
*These offsets are always the same when the program launch.
*/

enum ObjectOffsets : DWORD
{
	Type = 0x14,
	Pos_X = 0x79C,
	Pos_Y = 0x798,
	Pos_Z = 0x7A0,
	Rot = 0x7A8,
	Guid = 0x30,
	UnitFields = 0x8,
	Swimming = 0x75E439,
	Flying = 0x7CF
};

enum UnitOffsets : DWORD
{
	Level = 0x36 * 4,
	Health = 0x18 * 4,
	Energy = 0x19 * 4,
	MaxHealth = 0x20 * 4,
	SummonedBy = 0xE * 4,
	MaxEnergy = 0x21 * 4
};

enum ClientOffsets : DWORD
{
	StaticClientConnection = 0x00C79CE0,
	ObjectManagerOffset = 0x2ED0,
	FirstObjectOffset = 0xAC,
	LocalGuidOffset = 0xC0,
	NextObjectOffset = 0x3C,
	LocalPlayerGUID = 0xBD07A8,
	LocalTargetGUID = 0x00BD07B0,
	MapId = 0x0BD080C,
	ZoneId = 0x00BD0804,
	Movement = 0xD8,
	IsFlying = 0x44
};

enum NameOffsets : DWORDLONG
{
	nameStore = 0x00C5D938 + 0x8,
	nameMask = 0x24,
	nameBase = 0x1C,
	nameString = 0x20
};

DWORD mem_location::getObjectBaseByGuid(memreader mem, DWORD firstObject, DWORDLONG guid) {

	DWORD baseTmp = firstObject;
	DWORDLONG tmpGuid;

	while (baseTmp != 0)
	{
		tmpGuid = mem.readUInt64((LPVOID)(baseTmp + ObjectOffsets::Guid));
		
		if (tmpGuid == guid) {
			return baseTmp;
		}
		
		baseTmp = mem.readUInt32((LPVOID)(baseTmp + ClientOffsets::NextObjectOffset));
	}

	return 0;
}

void mem_location::loadFromMemory() {
	
	clientConnection = mem.readUInt32((LPVOID)ClientOffsets::StaticClientConnection);
	objectManager = mem.readUInt32((LPVOID)(clientConnection + ClientOffsets::ObjectManagerOffset));
	firstObject = mem.readUInt32((LPVOID)(objectManager + ClientOffsets::FirstObjectOffset));
	targetGuid = mem.readUInt64((LPVOID)(ClientOffsets::LocalTargetGUID));
	playerGuid = mem.readUInt64((LPVOID)(objectManager + ClientOffsets::LocalGuidOffset));

	playerBase = getObjectBaseByGuid(mem, firstObject, playerGuid);
}

INT mem_location::readMapId() {

	loadFromMemory();

	INT mapId = mem.readInt((LPVOID)ClientOffsets::MapId);
	return mapId;
}

INT mem_location::readZoneId() {

	loadFromMemory();

	INT zoneId = mem.readInt((LPVOID)ClientOffsets::ZoneId);
	return zoneId;
}

void mem_location::writePos(FLOAT x, FLOAT y, FLOAT z) {
	
	loadFromMemory();
	
	if (x != NULL) {
		mem.writeFloat((LPVOID)(playerBase + ObjectOffsets::Pos_X), x);
	}

	if (y != NULL) {
		mem.writeFloat((LPVOID)(playerBase + ObjectOffsets::Pos_Y), y);
	}

	if (z != NULL) {
		mem.writeFloat((LPVOID)(playerBase + ObjectOffsets::Pos_Z), z);
	}
}

FLOAT mem_location::readPosX() {
	
	loadFromMemory();

	FLOAT x = mem.readFloat((LPVOID)(playerBase + ObjectOffsets::Pos_X));
	return x;
}

FLOAT mem_location::readPosY() {

	loadFromMemory();

	FLOAT y = mem.readFloat((LPVOID)(playerBase + ObjectOffsets::Pos_Y));
	
	return y;
}

FLOAT mem_location::readPosZ() {
	
	loadFromMemory();

	FLOAT z = mem.readFloat((LPVOID)(playerBase + ObjectOffsets::Pos_Z));

	return z;
}

void mem_location::writePosX(FLOAT x) {

	loadFromMemory();

	if (x != NULL) {
		mem.writeFloat((LPVOID)(playerBase + ObjectOffsets::Pos_X), x);
	}
}

void mem_location::writePosY(FLOAT y) {

	loadFromMemory();

	if (y != NULL) {
		mem.writeFloat((LPVOID)(playerBase + ObjectOffsets::Pos_Y), y);
	}
}

void mem_location::writePosZ(FLOAT z) {

	loadFromMemory();

	if (z != NULL) {
		mem.writeFloat((LPVOID)(playerBase + ObjectOffsets::Pos_Z), z);
	}
}

DWORD mem_location::readHP() {
	
	loadFromMemory();

	DWORD unitFieldsAddress = mem.readUInt32((LPVOID)(playerBase + ObjectOffsets::UnitFields));
	DWORD hp = mem.readUInt32((LPVOID)(unitFieldsAddress + UnitOffsets::Health));

	return hp;
}

void mem_location::writeHP(DWORD hp) {

	loadFromMemory();

	DWORD unitFieldsAddress = mem.readUInt32((LPVOID)(playerBase + ObjectOffsets::UnitFields));
	mem.writeUInt32((LPVOID)(unitFieldsAddress + UnitOffsets::Health), hp);
}

void mem_location::writeZoneId(INT id) {

	loadFromMemory();

	mem.writeInt((LPVOID)(ClientOffsets::ZoneId), id);
}

void mem_location::liftPosZ() {

	loadFromMemory();

	FLOAT z = readPosZ() + DISTANCE_Z;

	writePosZ(z);
}

void mem_location::landPosZ() {

	loadFromMemory();

	FLOAT z = readPosZ() - DISTANCE_Z;

	writePosZ(z);
}

void mem_location::writeSpeed(FLOAT speed) {

	loadFromMemory();

	mem.writeFloat((LPVOID)(ClientOffsets::Movement), speed);
}

FLOAT mem_location::readSpeed() {

	loadFromMemory();

	FLOAT speed = mem.readFloat((LPVOID)(playerBase + ClientOffsets::Movement));

	return speed;
}

void mem_location::writeFly(DWORD flying) {

	loadFromMemory();

	DWORD current = readFly();

	if (current > FLYSTATUS) {
	//	flying = -flying;
	}

	DWORD fly = readFly() + flying;

	mem.writeInt((LPVOID)(playerBase + ObjectOffsets::Flying), fly);
}

DWORD mem_location::readFly() {

	loadFromMemory();

	DWORD flying = mem.readInt((LPVOID)(playerBase + ObjectOffsets::Flying));

	return flying;
}

DWORD mem_location::readSwimming() {

	loadFromMemory();

	DWORD unitFieldsAddress = mem.readUInt32((LPVOID)(playerBase + ObjectOffsets::UnitFields));
	DWORD swimming = mem.readUInt32((LPVOID)(ObjectOffsets::Swimming));

	return swimming;
}